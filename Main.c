#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl11, ARM_SENSOR,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  TRANSLATION_SENSOR, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mogo_r,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           chassis_r,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           arm_1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           translation_l, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           arm_2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           translation_r, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           arm_3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm_4,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           chassis_l,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mogo_l,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Mod_Vex_Comp_Control.c"
#include "motor.h"
#include "Control.c"
#include "Auton.h"

void
init( ) {
	strTeam = "Gort";
	bLCDAuton =
	bLCDUserControl = true;
	bTrueSpeed = false;
}

const int kMaxNumberOfPages = 5;
const int kMinNumberOfPages = 1;
int iAuton = 1;
string rgSAuton[kMaxNumberOfPages] = {"LEFT 20", "RIGHT 20", "LEFT 5", "RIGHT 5", "PUSH"};
void
pre_auton( ) {
	clearAllEncoder();
	clearLCDLines();
	while(!bIfiAutonomousMode && bIfiRobotDisabled) {
		if( nLCDButtons == 1 ) {
			iAuton = iAuton == kMinNumberOfPages ? kMaxNumberOfPages : iAuton - 1;
			waitForRelease( );
		}
		if( nLCDButtons == 4 ) {
			iAuton = iAuton == kMaxNumberOfPages ? kMinNumberOfPages : iAuton + 1;
			waitForRelease( );
		}
		if( nLCDButtons == 2 ) {
			waitForRelease( );
			break;
		}

		displayLCDCenteredString(0, rgSAuton[iAuton - 1]);
		displayLCDCenteredString( 1, "<    Select    >");
		delay( 50 );
		clearLCDLines( );
	}
}

task
autonomous( ) {
	switch(iAuton) {
		//LEFT 20
		case 1:
			autonStart();
			twentyPointScore(true);
			break;
		//RIGHT 20
		case 2:
			autonStart();
			twentyPointScore(false);
			break;
		//LEFT 5
		case 3:
			autonStart();
			fivePointScore(true);
			break;
		//RIGHT 5
		case 4:
			autonStart();
			fivePointScore(false);
			break;
		//PUSH
		case 5:
			SensorValue[ARM_SENSOR] = 0;
			armPID(100);
			tank(-127, -127);
			delay(4000);
			tank(0, 0);
			break;
		default:
			break;
	}
}

static bool bPresetOn;
task
armControl(  ) {
	while(true) {
		if(vexRT[Btn8DXmtr2]) {
			bPresetOn = true;
		}

		if(vexRT[Btn6UXmtr2] || vexRT[Btn6DXmtr2]) {
			arm( vexRT[Btn6UXmtr2]?127:(vexRT[Btn6DXmtr2]?-80:10) );
			bPresetOn = false;
		}
		else if(bPresetOn) {
			arm((80-getArm())*0.8);
		}
		else {
			arm(10);
		}

		if(vexRT[Btn8LXmtr2]) {
			arm(-40);
			while(vexRT[Btn8LXmtr2]) {
				delay( 1 ); //Don't hog the CPU!
			}
			SensorValue[ARM_SENSOR] = 0;
		}
	}
}

task
teleop( ) {
	SensorValue[ARM_SENSOR] = 0;
	startTask(armControl);
	while(true) {

		/* Chassis */
		//No Truespeed
		tankWithoutTrueSpeed( (vexRT[Ch3]), (vexRT[Ch2]) );

		/* Four bar */
		//Directional Brake
		translationalControl();

		/* Mogo */
		mogoSet((vexRT[Btn5D]-vexRT[Btn5U])*127);

		delay( 20 ); //Don't hog the CPU!
	}
}
